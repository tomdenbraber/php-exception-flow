<?php
namespace PhpExceptionFlow;

use PhpParser\Node;
use PhpParser\Node\Stmt\Throw_;
use PHPTypes\Type;


class Scope {
	/** @var string $name */
	private $name;
	/** @var Node[] $instructions */
	private $instructions;
	/** @var GuardedScope[] $guarded_scopes */
	private $guarded_scopes;
	/** @var GuardedScope $enclosing_guarded_scope */
	private $enclosing_guarded_scope;

	/** @var \SplObjectStorage */
	private $call_exception_map;

	/** @var Type[] $propagates */
	private $propagates;
	/** @var Type[] $generates */
	private $generates;
	/** @var Type[] $raises*/
	private $raises;
	/** @var Type[] $uncaught */
	private $uncaught;

	/**
	 * Scope constructor.
	 * @param string $name
	 * @param GuardedScope $enclosing_guarded_scope
	 * @param Node[] $instructions
	 * @param GuardedScope[] $guarded_scopes
	 */
	public function __construct($name, GuardedScope $enclosing_guarded_scope = null, $instructions = array(), $guarded_scopes = array()) {
		$this->name = $name;
		$this->instructions = array();
		$this->guarded_scopes = array();

		$this->enclosing_guarded_scope = $enclosing_guarded_scope;

		foreach ($instructions as $instruction) {
			$this->addInstruction($instruction);
		}

		foreach ($guarded_scopes as $guarded_scope) {
			$this->addGuardedScope($guarded_scope);
		}

		$this->call_exception_map = new \SplObjectStorage;

		$this->propagates = array();
		$this->generates = array();
		$this->raises = array();
		$this->uncaught = array();
	}

	/**
	 * @param Node $stmt
	 */
	public function addInstruction(Node $stmt) {
		$this->instructions[] = $stmt;
	}

	/**
	 * @param GuardedScope $guarded_scope
	 */
	public function addGuardedScope(GuardedScope $guarded_scope) {
		$this->guarded_scopes[] = $guarded_scope;
	}

	/**
	 * @param GuardedScope $guarded_scope
	 */
	public function setEnclosingGuardedScope(GuardedScope $guarded_scope) {
		$this->enclosing_guarded_scope = $guarded_scope;
	}

	/**
	 * @return string
	 */
	public function getName() {
		return $this->name;
	}

	/**
	 * @return Node[]
	 */
	public function getInstructions() {
		return $this->instructions;
	}

	/**
	 * @return GuardedScope[]
	 */
	public function getGuardedScopes() {
		return $this->guarded_scopes;
	}

	/**
	 * @return GuardedScope
	 */
	public function getEnclosingGuardedScope() {
		return $this->enclosing_guarded_scope;
	}

	/**
	 * @return bool
	 */
	public function isEnclosed() {
		return $this->enclosing_guarded_scope !== null;
	}

	/**
	 * @param Node $call
	 * @param array $exception_types
	 */
	public function injectExceptionsFromCall(Node $call, array $exception_types) {
		if ($this->call_exception_map->contains($call) === true) {
			$old_types = $this->call_exception_map[$call];
			$exception_types = array_unique(array_merge($old_types, $exception_types));
		}
		$this->call_exception_map[$call] = $exception_types;
	}

	/**
	 * TODO: THE SETS DETERMINATION IS MAYBE BETTER DONE IN A SEPARATE CLASS.
	 */

	/**
	 * Calculate the set of exceptions that are explicitly raised (thrown) within this scope
	 */
	private function determineRaises() {
		$this->raises = array();
		foreach ($this->instructions as $instruction) {
			if ($instruction instanceof Throw_) {
				/** @var Type $type */
				$type = $instruction->expr->getAttribute("type", new Type(Type::TYPE_UNKNOWN));
				$this->raises[(string)$type] = $type;
			}
		}
	}

	/**
	 * Determine the set of Exceptions that are propagated by this scope
	 * This happens when this scope calls another scope, and the other scope encounters an Exception
	 */
	private function determinePropagates() {
		foreach ($this->call_exception_map as $func_call) {
			$this->propagates = array_merge($this->propagates, $this->call_exception_map[$func_call]);
		}
		$this->propagates = array_unique($this->propagates);
	}

	/**
	 * Determine the set of Exceptions that are generated by the instructions in this scope
	 */
	private function determineGenerates() {

	}

	/**
	 * Determine the set of Exceptions that are encountered in the enclosed guarded scopes, but not caught.
	 */
	private function determineUncaught() {
		foreach ($this->guarded_scopes as $guarded_scope) {
			$this->uncaught = array_merge($this->uncaught, $guarded_scope->getUncaught());
		}
		$this->uncaught = array_unique($this->uncaught);
	}

	/**
	 * Determines the propagates, generates, uncaught and raises sets
	 */
	public function determineEncounters() {
		$this->determineRaises();
		$this->determinePropagates();
		$this->determineGenerates();
		$this->determineUncaught();
	}

	/**
	 * encounters is the set of raises, propagates, generates, uncaught.
	 * @return Type[]
	 */
	public function getEncounters($determine_first = false) {
		if ($determine_first === true) {
			$this->determineEncounters();
		}
		return array_unique(array_merge($this->raises, $this->propagates, $this->generates, $this->uncaught));
	}

}